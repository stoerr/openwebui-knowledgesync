#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const {URL} = require('url');
const http = require('http');
const https = require('https');

const debug = false; // Set to true for debug output

/* Prints usage: commands are listkb, listfiles */
function usage() {
    console.log('Usage: openwebui-knowledgesync [command]');
    console.log('Commands:');
    console.log('  sync         Performs the synchronization of the configured knowledge base with the current directory.');
    console.log('               All files in the knowledge base that do not correspond to files in the current directory will be deleted.');
    console.log('               All files in the current directory will be uploaded / changed if needed.');
    console.log('  listkb       List knowledge bases');
    console.log('  listfiles    List all files');
    console.log('  listkbfiles  List files in a knowledge base');
    console.log('  download <fileid>  Download a file from the knowledge base by its ID and write it to stdout');
}

// Helper: get all files matching fileregex recursively (excluding config, script)
function getLocalFiles(dir = process.cwd(), relativePath = '', regexPattern = null) {
    const files = [];

    // Compile regex pattern if provided
    const fileRegex = regexPattern ? new RegExp(regexPattern) : null;

    const entries = fs.readdirSync(dir);

    for (const entry of entries) {
        const fullPath = path.join(dir, entry);
        const relativeFilePath = relativePath ? path.join(relativePath, entry) : entry;

        // Skip dot files, config file, and script file
        if (entry.startsWith('.') ||
            fullPath === path.join(process.cwd(), path.basename(__filename)) ||
            fullPath === configPath) {
            continue;
        }

        const stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
            files.push(...getLocalFiles(fullPath, relativeFilePath, regexPattern));
        } else if (stat.isFile()) {
            // Include the file only if it matches the regex or if no regex is provided
            if (!fileRegex || fileRegex.test(relativeFilePath)) {
                files.push(relativeFilePath);
            }
        }
    }

    return files;
}

// Helper: compute SHA256 hash of file
function fileHash(filename) {
    const data = fs.readFileSync(filename);
    return crypto.createHash('sha256').update(data).digest('hex');
}

// Helper: make HTTP request returning JSON or raw data
function httpRequest(method, apiPath, body = null, contentType = 'application/json', parseJson = true) {
    return new Promise((resolve, reject) => {
        const url = new URL(apiPath, openWebuiApiUrl);
        const lib = url.protocol === 'https:' ? https : http;
        const headers = {
            'Authorization': `Bearer ${openWebuiApiKey}`,
            'Accept': parseJson ? 'application/json' : '*/*'
        };

        if (contentType) headers['Content-Type'] = contentType;
        if (body && contentType === 'application/json') {
            body = JSON.stringify(body);
            headers['Content-Length'] = Buffer.byteLength(body);
        }

        const options = {
            hostname: url.hostname,
            port: url.port,
            path: url.pathname + url.search,
            method: method,
            headers: headers
        };

        const req = lib.request(options, res => {
            if (!parseJson) {
                // For non-JSON responses (like file downloads), pipe directly to stdout
                if (res.statusCode !== 200) {
                    console.error(`HTTP ${res.statusCode}: ${res.statusMessage}`);
                    process.exit(1);
                }
                res.pipe(process.stdout);
                res.on('end', () => resolve());
                return;
            }

            // For JSON responses
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve(data);
                }
            });
        });

        req.on('error', reject);
        if (body) req.write(body);
        req.end();
    });
}

// Helper: encode filename with kbdir_id prefix and %% separators
function encodeFilename(filename, kbdirId) {
    const encodedPath = filename.replace(/[/\\]/g, '%%');
    return `${kbdirId}%%${encodedPath}`;
}

// Helper: decode filename from OpenWebUI format and check if it belongs to our kbdir_id
function decodeFilename(encodedName, kbdirId) {
    const prefix = `${kbdirId}%%`;
    if (!encodedName.startsWith(prefix)) {
        return null; // Not from our directory
    }
    return encodedName.substring(prefix.length).replace(/%%/g, '/');
}

// Helper: upload file using multipart form data
function uploadFile(filename, kbdirId) {
    return new Promise((resolve, reject) => {
        const boundary = '----WebKitFormBoundary' + Math.random().toString(16).slice(2);
        const url = new URL('/api/v1/files/', openWebuiApiUrl);
        const lib = url.protocol === 'https:' ? https : http;
        const fileContent = fs.readFileSync(filename);

        // Encode filename with kbdir_id prefix
        const encodedFilename = encodeFilename(filename, kbdirId);

        const payloadStart = Buffer.from(
            `--${boundary}\r\n` +
            `Content-Disposition: form-data; name="file"; filename="${encodedFilename}"\r\n\r\n`
        );
        const payloadEnd = Buffer.from(`\r\n--${boundary}--\r\n`);
        const contentLength = payloadStart.length + fileContent.length + payloadEnd.length;

        const options = {
            hostname: url.hostname,
            port: url.port,
            path: url.pathname,
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${openWebuiApiKey}`,
                'Accept': 'application/json',
                'Content-Type': `multipart/form-data; boundary=${boundary}`,
                'Content-Length': contentLength
            }
        };

        const req = lib.request(options, res => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(e);
                }
            });
        });

        req.on('error', reject);
        req.write(payloadStart);
        req.write(fileContent);
        req.write(payloadEnd);
        req.end();
    });
}

// Helper: remove file from knowledge base (first from collection, then from storage)
async function removeFileFromKnowledgeBase(fileId) {
    try {
        // First remove from knowledge collection
        console.log(`Removing file ${fileId} from knowledge collection...`);
        const removeUrl = `/api/v1/knowledge/${knowledgeBaseId}/file/remove`;
        const kbremoveresponse = await httpRequest('POST', removeUrl, {'file_id': fileId});
        if (!kbremoveresponse?.id) {
            console.error(`Failed to remove file from knowledge collection.`);
            console.error('Remove response:', JSON.stringify(kbremoveresponse, null, 2));
        }

        // Then delete from file storage seems already done, so we can skip this step:
        // console.log(`Deleting file ${fileId} from file storage...`);
        // const deleteUrl = `/api/v1/files/${fileId}`;
        // const remfileresponse = await httpRequest('DELETE', deleteUrl);
    } catch (error) {
        console.error(`Error deleting file ${fileId}:`, error.message);
        throw error;
    }
}

function listKnowledgeBases() {
    httpRequest('GET', '/api/v1/knowledge/')
        .then(json => {
            const simplified = json.map(kb => ({
                id: kb.id,
                name: kb.name,
                description: kb.description
            }));
            console.log(JSON.stringify(simplified, null, 2));
        })
        .catch(err => console.error('Request error:', err.message));
}

function listFiles() {
    httpRequest('GET', '/api/v1/files/')
        .then(json => console.log(JSON.stringify(json, null, 2)))
        .catch(err => console.error('Request error:', err.message));
}

function listFilesInKnowledgeBase(id) {
    httpRequest('GET', `/api/v1/knowledge/${id}`)
        .then(json => console.log(JSON.stringify(json, null, 2)))
        .catch(err => console.error('Request error:', err.message));
}

async function syncKnowledgeBase() {
    try {
        console.log('Starting knowledge base synchronization...');

        // 1. Get local files and their hashes - now using fileRegex
        const localFiles = getLocalFiles(process.cwd(), '', fileRegex);
        const localHashes = {};
        for (const filename of localFiles) {
            localHashes[filename] = fileHash(filename);
        }
        console.log(`Found ${localFiles.length} local files.`);

        // 2. Get current knowledge base state
        const kbData = await httpRequest('GET', `/api/v1/knowledge/${knowledgeBaseId}`);
        const kbFiles = kbData.files || [];
        console.log(`Knowledge base contains ${kbFiles.length} files.`);

        // Debug: log KB files with their decoded names
        if (debug) {
            console.log('Knowledge base files:');
            kbFiles.forEach(file => {
                const decodedName = decodeFilename(file.meta.name, kbdirId);
                console.log(`- ${file.id}: ${file.meta.name} -> ${decodedName}`);
            });
        }

        // 3. Get all files to find hash information and build maps for reuse
        const allFiles = await httpRequest('GET', '/api/v1/files/');
        const fileHashMap = {};
        const fileByNameAndHash = new Map(); // Map for reusing existing files
        const fileIdByDecodedName = new Map(); // Map to track file IDs by decoded name

        for (const file of allFiles) {
            if (file.hash) {
                // Decode filename and check if it belongs to our directory
                const decodedName = decodeFilename(file.meta.name, kbdirId);
                if (decodedName !== null) {
                    fileHashMap[decodedName] = file.hash;
                    fileIdByDecodedName.set(decodedName, file.id);
                    if (debug) console.log(`Remote file mapping: "${decodedName}" -> ${file.id} (hash: ${file.hash})`);
                }

                // Also build map for all files by name and hash for reuse
                const key = `${file.meta.name}:${file.hash}`;
                fileByNameAndHash.set(key, file);
            }
        }

        // 4. Delete files from KB that belong to our kbdir_id but don't exist locally or have different hashes
        if (debug) console.log('\nChecking for files to delete:');
        for (const kbFile of kbFiles) {
            // Decode filename and check if it belongs to our directory
            const filename = decodeFilename(kbFile.meta.name, kbdirId);
            if (filename !== null) {
                // This file belongs to our directory
                const localHash = localHashes[filename];
                const remoteHash = fileHashMap[filename];

                if (debug) {
                    console.log(`\nEvaluating KB file: ${filename}`);
                    console.log(`- Local hash: ${localHash || 'NOT FOUND LOCALLY'}`);
                    console.log(`- Remote hash: ${remoteHash || 'UNKNOWN'}`);
                    console.log(`- In local files list: ${localFiles.includes(filename) ? 'YES' : 'NO'}`);
                }

                if (!localFiles.includes(filename)) {
                    // File doesn't exist locally anymore - delete it
                    console.log(`Deleting file from knowledge base (no longer exists locally): ${filename}`);
                    await removeFileFromKnowledgeBase(kbFile.id);
                } else if (localHash !== remoteHash) {
                    // File exists but has different hash - delete old version
                    console.log(`Deleting file from knowledge base (content changed): ${filename}`);
                    await removeFileFromKnowledgeBase(kbFile.id);
                } else {
                    console.log(`Keeping file (unchanged): ${filename}`);
                }
                // If localHash === remoteHash, file is up to date, keep it
            } else {
                console.log(`Skipping non-directory file: ${kbFile.meta.name}`);
            }
            // If filename is null, this file doesn't belong to our directory, leave it alone
        }

        // 5. Upload and add new/changed files
        if (debug) console.log('\nChecking for files to add or update:');
        for (const filename of localFiles) {
            const localHash = localHashes[filename];
            const remoteHash = fileHashMap[filename];

            if (debug) {
                console.log(`\nProcessing local file: ${filename}`);
                console.log(`- Local hash: ${localHash}`);
                console.log(`- Remote hash: ${remoteHash || 'NOT IN KB'}`);
            }

            // Check if this file is already in the knowledge base with the correct content
            const fileInKb = kbFiles.some(f => {
                const decodedName = decodeFilename(f.meta.name, kbdirId);
                return decodedName === filename;
            });

            if (debug) {
                console.log(`- Already in knowledge base: ${fileInKb ? 'YES' : 'NO'}`);
                console.log(`- Hash match: ${localHash === remoteHash ? 'YES' : 'NO'}`);
            }

            // Check if file needs to be uploaded
            if (!fileInKb || localHash !== remoteHash) {
                let fileId = null;
                const encodedFilename = encodeFilename(filename, kbdirId);
                const reuseKey = `${encodedFilename}:${localHash}`;

                // Check if we can reuse an existing file with same name and hash
                const existingFile = fileByNameAndHash.get(reuseKey);
                if (existingFile) {
                    console.log(`Reusing existing file: ${filename} (${existingFile.id})`);
                    fileId = existingFile.id;
                } else {
                    console.log(`Uploading file: ${filename}`);
                    const uploadResult = await uploadFile(filename, kbdirId);

                    // Check if upload was successful
                    if (!uploadResult || !uploadResult.id) {
                        console.error(`Upload failed for ${filename}: No file ID in response`);
                        console.error('Upload response:', JSON.stringify(uploadResult, null, 2));
                        continue; // Skip this file
                    }

                    // Verify that the uploaded file's hash matches the local file's hash
                    if (uploadResult.hash && uploadResult.hash !== localHash) {
                        console.error(`Hash mismatch for uploaded file ${filename}:`);
                        console.error(`  Local hash:    ${localHash}`);
                        console.error(`  Uploaded hash: ${uploadResult.hash}`);
                        console.error('This may indicate upload corruption or file processing issues - is that actually UTF-8?');
                        // Continue with the process but log the issue
                    }
                    fileId = uploadResult.id;
                    console.log(`File uploaded successfully: ${filename} (${fileId})`);
                }

                // Add file to knowledge base
                console.log(`Adding file to knowledge base: ${filename}`);
                try {
                    const addResult = await httpRequest('POST', `/api/v1/knowledge/${knowledgeBaseId}/file/add`, {
                        file_id: fileId
                    });

                    // Check if adding to knowledge base was successful
                    if (!addResult?.id) {
                        console.error(`Failed to add file to knowledge base: ${filename}`);
                        console.error('Add response:', JSON.stringify(addResult, null, 2));

                        // If we uploaded the file (didn't reuse), delete it to save space
                        if (!existingFile) {
                            console.log(`Cleaning up uploaded file: ${filename} (${fileId})`);
                            await httpRequest('DELETE', `/api/v1/files/${fileId}`);
                        }
                        continue;
                    }

                    console.log(`File added to knowledge base successfully: ${filename}`);
                } catch (err) {
                    console.error(`Failed to add file to knowledge base: ${filename}`, err.message);

                    // If we uploaded the file (didn't reuse), delete it to save space
                    if (!existingFile) {
                        console.log(`Cleaning up uploaded file: ${filename} (${fileId})`);
                        await httpRequest('DELETE', `/api/v1/files/${fileId}`);
                    }
                }
            } else {
                console.log(`Skipping file (unchanged and already in KB): ${filename}`);
            }
        }

        console.log('Synchronization completed successfully!');
    } catch (error) {
        console.error('Synchronization failed:', error.message || error);
        process.exit(1);
    }
}

async function downloadFile(fileId) {
    try {
        await httpRequest('GET', `/api/v1/files/${fileId}/content`, null, null, false);
    } catch (error) {
        console.error(`Error downloading file ${fileId}:`, error.message);
        process.exit(1);
    }
}

// Main execution
const args = process.argv.slice(2);
if (args.length === 0) {
    usage();
    process.exit(1);
}
const command = args[0];

const configPath = path.join(process.cwd(), '.open-webui-knowledgesync');
if (!fs.existsSync(configPath)) {
    console.error('Configuration file not found:', configPath);
    process.exit(1);
}
const config = fs.readFileSync(configPath, 'utf8').trim().split('\n').reduce((acc, line) => {
    const [key, value] = line.split('=');
    acc[key.trim()] = value.trim();
    return acc;
}, {});

if (!config.open_webui_api_key) {
    console.error('Missing required configuration: open_webui_api_key');
    process.exit(1);
}

const knowledgeBaseId = config.knowledge_base_id;
const openWebuiApiKey = config.open_webui_api_key;
const openWebuiApiUrl = config.open_webui_api_url || 'http://localhost:3000';
const kbdirId = config.kbdir_id;
const fileRegex = config.fileregex; // Add fileregex from config

// call functions based on command
if (command === 'sync') {
    if (!knowledgeBaseId) {
        console.error('Knowledge base ID is required for sync command.');
        process.exit(1);
    }
    if (!kbdirId) {
        console.error('kbdir_id is required for sync command.');
        process.exit(1);
    }
    syncKnowledgeBase();
} else if (command === 'listkb') {
    listKnowledgeBases();
} else if (command === 'listfiles') {
    listFiles();
} else if (command === 'listkbfiles') {
    if (!knowledgeBaseId) {
        console.error('Knowledge base ID is required for this command.');
        process.exit(1);
    }
    listFilesInKnowledgeBase(knowledgeBaseId);
} else if (command === 'download' && args.length === 2) {
    const fileId = args[1];
    if (!fileId) {
        console.error('File ID is required for download command.');
        process.exit(1);
    }
    downloadFile(fileId);
} else {
    usage();
    process.exit(1);
}
