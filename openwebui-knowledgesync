#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const {URL} = require('url');
const http = require('http');
const https = require('https');

/* Prints usage: commands are listkb, listfiles */
function usage() {
    console.log('Usage: open-webui-knowledgesync [command]');
    console.log('Commands:');
    console.log('  sync         Performs the synchronization of the configured knowledge base with the current directory.');
    console.log('               All files in the knowledge base that do not correspond to files in the current directory will be deleted.');
    console.log('               All files in the current directory will be uploaded / changed if needed.');
    console.log('  listkb       List knowledge bases');
    console.log('  listfiles    List all files');
    console.log('  listkbfiles  List files in a knowledge base');
}

// Helper: parse gitignore file and return array of patterns
function parseGitignore(gitignorePath) {
    if (!fs.existsSync(gitignorePath)) {
        return [];
    }
    const content = fs.readFileSync(gitignorePath, 'utf8');
    return content
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'))
        .map(pattern => {
            // Convert gitignore pattern to regex-like matching
            // Simple implementation - can be enhanced for more complex patterns
            if (pattern.endsWith('/')) {
                // Directory pattern
                return { pattern: pattern.slice(0, -1), isDirectory: true };
            } else {
                // File or directory pattern
                return { pattern: pattern, isDirectory: false };
            }
        });
}

// Helper: check if a path matches gitignore patterns
function isIgnored(filePath, gitignorePatterns) {
    const pathParts = filePath.split(path.sep);

    for (const rule of gitignorePatterns) {
        const pattern = rule.pattern;

        // Simple pattern matching - exact match or ends with pattern
        if (pattern.includes('*')) {
            // Basic wildcard support
            const regexPattern = pattern
                .replace(/\./g, '\\.')
                .replace(/\*/g, '.*');
            const regex = new RegExp(`^${regexPattern}$`);

            if (regex.test(filePath) || pathParts.some(part => regex.test(part))) {
                return true;
            }
        } else {
            // Exact match
            if (filePath === pattern ||
                filePath.endsWith('/' + pattern) ||
                pathParts.includes(pattern)) {
                return true;
            }

            // Directory pattern - check if any parent directory matches
            if (rule.isDirectory && pathParts.includes(pattern)) {
                return true;
            }
        }
    }

    return false;
}

// Helper: get all non-dot files recursively (excluding config, script, and gitignored files)
function getLocalFiles(dir = process.cwd(), relativePath = '', gitignorePatterns = null) {
    const files = [];

    // Load gitignore patterns from current directory if not provided
    if (gitignorePatterns === null) {
        const gitignorePath = path.join(process.cwd(), '.gitignore');
        gitignorePatterns = parseGitignore(gitignorePath);
    }

    const entries = fs.readdirSync(dir);

    for (const entry of entries) {
        const fullPath = path.join(dir, entry);
        const relativeFilePath = relativePath ? path.join(relativePath, entry) : entry;

        // Skip dot files, config file, and script file
        if (entry.startsWith('.') ||
            fullPath === path.join(process.cwd(), path.basename(__filename)) ||
            fullPath === configPath) {
            continue;
        }

        // Skip gitignored files
        if (isIgnored(relativeFilePath, gitignorePatterns)) {
            continue;
        }

        const stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
            files.push(...getLocalFiles(fullPath, relativeFilePath, gitignorePatterns));
        } else if (stat.isFile()) {
            files.push(relativeFilePath);
        }
    }

    return files;
}

// Helper: compute SHA256 hash of file
function fileHash(filename) {
    const data = fs.readFileSync(filename);
    return crypto.createHash('sha256').update(data).digest('hex');
}

// Helper: make HTTP request returning JSON
function httpRequest(method, apiPath, body = null, contentType = 'application/json') {
    return new Promise((resolve, reject) => {
        const url = new URL(apiPath, openWebuiApiUrl);
        const lib = url.protocol === 'https:' ? https : http;
        const headers = {
            'Authorization': `Bearer ${openWebuiApiKey}`,
            'Accept': 'application/json'
        };

        if (contentType) headers['Content-Type'] = contentType;
        if (body && contentType === 'application/json') {
            body = JSON.stringify(body);
            headers['Content-Length'] = Buffer.byteLength(body);
        }

        const options = {
            hostname: url.hostname,
            port: url.port,
            path: url.pathname + url.search,
            method: method,
            headers: headers
        };

        const req = lib.request(options, res => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve(data);
                }
            });
        });

        req.on('error', reject);
        if (body) req.write(body);
        req.end();
    });
}

// Helper: encode filename with kbdir_id prefix and %% separators
function encodeFilename(filename, kbdirId) {
    const encodedPath = filename.replace(/[/\\]/g, '%%');
    return `${kbdirId}%%${encodedPath}`;
}

// Helper: decode filename from OpenWebUI format and check if it belongs to our kbdir_id
function decodeFilename(encodedName, kbdirId) {
    const prefix = `${kbdirId}%%`;
    if (!encodedName.startsWith(prefix)) {
        return null; // Not from our directory
    }
    return encodedName.substring(prefix.length).replace(/%%/g, '/');
}

// Helper: upload file using multipart form data
function uploadFile(filename, kbdirId) {
    return new Promise((resolve, reject) => {
        const boundary = '----WebKitFormBoundary' + Math.random().toString(16).slice(2);
        const url = new URL('/api/v1/files/', openWebuiApiUrl);
        const lib = url.protocol === 'https:' ? https : http;
        const fileContent = fs.readFileSync(filename);

        // Encode filename with kbdir_id prefix
        const encodedFilename = encodeFilename(filename, kbdirId);

        const payloadStart = Buffer.from(
            `--${boundary}\r\n` +
            `Content-Disposition: form-data; name="file"; filename="${encodedFilename}"\r\n\r\n`
        );
        const payloadEnd = Buffer.from(`\r\n--${boundary}--\r\n`);
        const contentLength = payloadStart.length + fileContent.length + payloadEnd.length;

        const options = {
            hostname: url.hostname,
            port: url.port,
            path: url.pathname,
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${openWebuiApiKey}`,
                'Accept': 'application/json',
                'Content-Type': `multipart/form-data; boundary=${boundary}`,
                'Content-Length': contentLength
            }
        };

        const req = lib.request(options, res => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(e);
                }
            });
        });

        req.on('error', reject);
        req.write(payloadStart);
        req.write(fileContent);
        req.write(payloadEnd);
        req.end();
    });
}

function listKnowledgeBases() {
    httpRequest('GET', '/api/v1/knowledge/')
        .then(json => {
            const simplified = json.map(kb => ({
                id: kb.id,
                name: kb.name,
                description: kb.description
            }));
            console.log(JSON.stringify(simplified, null, 2));
        })
        .catch(err => console.error('Request error:', err.message));
}

function listFiles() {
    httpRequest('GET', '/api/v1/files/')
        .then(json => console.log(JSON.stringify(json, null, 2)))
        .catch(err => console.error('Request error:', err.message));
}

function listFilesInKnowledgeBase(id) {
    httpRequest('GET', `/api/v1/knowledge/${id}`)
        .then(json => console.log(JSON.stringify(json, null, 2)))
        .catch(err => console.error('Request error:', err.message));
}

async function syncKnowledgeBase() {
    try {
        console.log('Starting knowledge base synchronization...');

        // 1. Get local files and their hashes
        const localFiles = getLocalFiles();
        const localHashes = {};
        for (const filename of localFiles) {
            localHashes[filename] = fileHash(filename);
        }
        console.log(`Found ${localFiles.length} local files`);

        // 2. Get current knowledge base state
        const kbData = await httpRequest('GET', `/api/v1/knowledge/${knowledgeBaseId}`);
        const kbFiles = kbData.files || [];
        console.log(`Knowledge base contains ${kbFiles.length} files`);

        // 3. Get all files to find hash information and build maps for reuse
        const allFiles = await httpRequest('GET', '/api/v1/files/');
        const fileHashMap = {};
        const fileByNameAndHash = new Map(); // Map for reusing existing files

        for (const file of allFiles) {
            if (file.hash) {
                // Decode filename and check if it belongs to our directory
                const decodedName = decodeFilename(file.meta.name, kbdirId);
                if (decodedName !== null) {
                    fileHashMap[decodedName] = file.hash;
                }

                // Also build map for all files by name and hash for reuse
                const key = `${file.meta.name}:${file.hash}`;
                fileByNameAndHash.set(key, file);
            }
        }

        // 4. Delete files from KB that belong to our kbdir_id but don't exist locally or have different hashes
        for (const kbFile of kbFiles) {
            // Decode filename and check if it belongs to our directory
            const filename = decodeFilename(kbFile.meta.name, kbdirId);
            if (filename !== null) {
                // This file belongs to our directory
                const localHash = localHashes[filename];
                const remoteHash = fileHashMap[filename];

                if (!localHash) {
                    // File doesn't exist locally anymore - delete it
                    console.log(`Deleting file from knowledge base (no longer exists locally): ${filename}`);
                    await httpRequest('DELETE', `/api/v1/files/${kbFile.id}`);
                } else if (localHash !== remoteHash) {
                    // File exists but has different hash - delete old version
                    console.log(`Deleting file from knowledge base (content changed): ${filename}`);
                    await httpRequest('DELETE', `/api/v1/files/${kbFile.id}`);
                }
                // If localHash === remoteHash, file is up to date, keep it
            }
            // If filename is null, this file doesn't belong to our directory, leave it alone
        }

        // 5. Upload and add new/changed files
        for (const filename of localFiles) {
            const localHash = localHashes[filename];
            const remoteHash = fileHashMap[filename];

            // Check if file needs to be uploaded
            if (localHash !== remoteHash) {
                let fileId = null;
                const encodedFilename = encodeFilename(filename, kbdirId);
                const reuseKey = `${encodedFilename}:${localHash}`;

                // Check if we can reuse an existing file with same name and hash
                const existingFile = fileByNameAndHash.get(reuseKey);
                if (existingFile) {
                    console.log(`Reusing existing file: ${filename} (${existingFile.id})`);
                    fileId = existingFile.id;
                } else {
                    console.log(`Uploading file: ${filename}`);
                    const uploadResult = await uploadFile(filename, kbdirId);

                    // Check if upload was successful
                    if (!uploadResult || !uploadResult.id) {
                        console.error(`Upload failed for ${filename}: No file ID in response`);
                        console.error('Upload response:', JSON.stringify(uploadResult, null, 2));
                        continue; // Skip this file
                    }

                    fileId = uploadResult.id;
                    console.log(`File uploaded successfully: ${filename} (${fileId})`);
                }

                // Add file to knowledge base
                console.log(`Adding file to knowledge base: ${filename}`);
                try {
                    const addResult = await httpRequest('POST', `/api/v1/knowledge/${knowledgeBaseId}/file/add`, {
                        file_id: fileId
                    });

                    // Check if adding to knowledge base was successful
                    if (!addResult || (!addResult.id && !addResult.file_id && !addResult.success)) {
                        console.error(`Failed to add file to knowledge base: ${filename}`);
                        console.error('Add response:', JSON.stringify(addResult, null, 2));

                        // If we uploaded the file (didn't reuse), delete it to save space
                        if (!existingFile) {
                            console.log(`Cleaning up uploaded file: ${filename} (${fileId})`);
                            await httpRequest('DELETE', `/api/v1/files/${fileId}`);
                        }
                        continue;
                    }

                    console.log(`File added to knowledge base successfully: ${filename}`);
                } catch (err) {
                    console.error(`Failed to add file to knowledge base: ${filename}`, err.message);

                    // If we uploaded the file (didn't reuse), delete it to save space
                    if (!existingFile) {
                        console.log(`Cleaning up uploaded file: ${filename} (${fileId})`);
                        await httpRequest('DELETE', `/api/v1/files/${fileId}`);
                    }
                }
            } else {
                // File exists with same hash - check if it's in the knowledge base
                const inKb = kbFiles.some(f => {
                    const decodedName = decodeFilename(f.meta.name, kbdirId);
                    return decodedName === filename;
                });
                if (!inKb) {
                    // Find existing file and add to KB
                    const existingFile = allFiles.find(f => {
                        const decodedName = decodeFilename(f.meta.name, kbdirId);
                        return decodedName === filename && f.hash === localHash;
                    });
                    if (existingFile) {
                        console.log(`Adding existing file to knowledge base: ${filename}`);
                        const addResult = await httpRequest('POST', `/api/v1/knowledge/${knowledgeBaseId}/file/add`, {
                            file_id: existingFile.id
                        });

                        // Check if adding was successful
                        if (!addResult || (!addResult.id && !addResult.file_id && !addResult.success)) {
                            console.error(`Failed to add existing file to knowledge base: ${filename}`);
                            console.error('Add response:', JSON.stringify(addResult, null, 2));
                        } else {
                            console.log(`Existing file added to knowledge base successfully: ${filename}`);
                        }
                    }
                }
            }
        }

        console.log('Synchronization completed successfully!');
    } catch (error) {
        console.error('Synchronization failed:', error.message || error);
        process.exit(1);
    }
}

// Main execution
const args = process.argv.slice(2);
if (args.length === 0) {
    usage();
    process.exit(1);
}
const command = args[0];

const configPath = path.join(process.cwd(), '.open-webui-knowledgesync');
if (!fs.existsSync(configPath)) {
    console.error('Configuration file not found:', configPath);
    process.exit(1);
}
const config = fs.readFileSync(configPath, 'utf8').trim().split('\n').reduce((acc, line) => {
    const [key, value] = line.split('=');
    acc[key.trim()] = value.trim();
    return acc;
}, {});

if (!config.open_webui_api_key) {
    console.error('Missing required configuration: open_webui_api_key');
    process.exit(1);
}

const knowledgeBaseId = config.knowledge_base_id;
const openWebuiApiKey = config.open_webui_api_key;
const openWebuiApiUrl = config.open_webui_api_url || 'http://localhost:3000';
const kbdirId = config.kbdir_id;

// call functions based on command
if (command === 'sync') {
    if (!knowledgeBaseId) {
        console.error('Knowledge base ID is required for sync command.');
        process.exit(1);
    }
    if (!kbdirId) {
        console.error('kbdir_id is required for sync command.');
        process.exit(1);
    }
    syncKnowledgeBase();
} else if (command === 'listkb') {
    listKnowledgeBases();
} else if (command === 'listfiles') {
    listFiles();
} else if (command === 'listkbfiles') {
    if (!knowledgeBaseId) {
        console.error('Knowledge base ID is required for this command.');
        process.exit(1);
    }
    listFilesInKnowledgeBase(knowledgeBaseId);
} else {
    usage();
    process.exit(1);
}
